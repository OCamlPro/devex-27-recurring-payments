/*
  Implementation of contract RPSUser
 */

pragma ton-solidity >= 0.32.0;

pragma AbiHeader expire;
pragma AbiHeader pubkey;

import "../libraries/RPSBase.sol";
import "../interfaces/IRPSProvider.sol";
import "../interfaces/IRPSCallback.sol";
import "../interfaces/IRPSUser.sol";
import "./MultiWallets.spp";

contract RPSUser is
IRPSUser
, MultiWallets
{
  address static s_root ;
  address static s_owner ;

  struct UserSubscription {
    uint64 sub_uid ;
    address provider ;
    uint32 serv_id ;
    uint8 periods ;
    address callback ;
    RPSBase.Service service ;
    RPSBase.Status status ;
    uint64 sub_pid ;
    uint64 sub_date ;
  }

  mapping ( uint64 => UserSubscription ) g_subscriptions ;
  uint64 g_subscription_counter ;

  function _check_owner() view
  {
    require(
            msg.sender.value != 0 ?
            msg.sender == s_owner :
            msg.pubkey() == tvm.pubkey(),
            RPSBase.EXN_AUTH_FAILED );
    tvm.accept();
  }

  constructor( ) public {
    _check_owner();
    tvm.accept();

    _MultiWallets();
  }

  function NeedWallet ( address token_root ) public
  {
    _check_owner();
    _need_wallet( token_root );
  }

  function Subscribe( address provider,
                      uint32 serv_id,
                      uint8 periods,
                      address callback ) public 
  {
    require( periods > 0 );
    _check_owner();

    RPSBase.Service empty_service;
    UserSubscription sub = UserSubscription(
                                           g_subscription_counter,
                                           provider,
                                           serv_id,
                                           periods,
                                           callback,
                                           empty_service,
                                           RPSBase.Status.Pending,
                                           0, // sub_pid
                                           0  // sub_date
                                           );
    g_subscriptions [ g_subscription_counter ] = sub ;
    g_subscription_counter++;

    IRPSProvider( provider ).
      prepareSubscribe %{sol:gas:1 ton} ( sub.sub_uid, serv_id );
  }

  function _get_subscription( uint64 sub_uid )
    internal inline view returns ( UserSubscription sub )
  {
    optional ( UserSubscription ) sub_opt = g_subscriptions.fetch(  sub_uid );
    require( sub_opt.hasValue(), RPSBase.EXN_AUTH_FAILED );
    sub = sub_opt.get() ;
  }

  function continueSubscribe( uint64 sub_uid,
                              RPSBase.Service s,
                              address token_wallet ) public override
  {
    UserSubscription sub = _get_subscription( sub_uid );
    require( sub.provider == msg.sender, RPSBase.EXN_AUTH_FAILED );

    uint128 cost = sub.periods * s.period_cost ;
    uint128 balance = _get_balance( s.token_root );

    if( cost >= balance ){
      _transfer( s.token_root, cost, token_wallet );
      g_subscriptions[ sub.sub_uid ].service = s;
      IRPSProvider( sub.provider ).subscribe(
                                             s_owner,
                                             tvm.pubkey(),
                                             sub_uid,
                                             sub.serv_id,
                                             sub.periods
                                              );
    } else {
      _callbackSubscribe( sub,
                          RPSBase.Status.ErrorNotEnoughBalance );
    }
  }

  function _callbackSubscribe( UserSubscription sub, RPSBase.Status status )
    internal 
  {
    sub.status = status;
    g_subscriptions[ sub.sub_uid ] = sub ;
    if( sub.callback.value != 0 ){
      IRPSCallback( sub.callback ).
        subscribeStatus %{sol:fwd} (
                        address(this),
                        sub.provider,
                        sub.sub_uid,
                        sub.serv_id,
                        sub.periods,
                        status,
                        sub.sub_date);
    }
  }
  
  function callbackSubscribe( uint64 sub_uid,
                              RPSBase.Status status) public override
  {
    UserSubscription sub = _get_subscription( sub_uid );
    require( sub.provider == msg.sender, RPSBase.EXN_AUTH_FAILED );

    _callbackSubscribe( sub, status );
  }

  function confirmSubscribe( uint64 sub_uid,
                             uint64 sub_pid,
                             uint64 sub_date
                             ) public 
  {
    UserSubscription sub = _get_subscription( sub_uid );
    require( sub.provider == msg.sender, RPSBase.EXN_AUTH_FAILED );

    sub.sub_pid = sub_pid ;
    sub.sub_date = sub_date ;
    _callbackSubscribe( sub, RPSBase.Status.Subscribed );
  }

  function stopSubscribe( uint64 sub_uid ) public view {
    _check_owner();
    UserSubscription sub = _get_subscription( sub_uid );
    IRPSProvider( sub.provider ).
      stopSubscribe( sub_uid, sub.sub_pid );
  }

  function stoppedSubscribe( uint64 sub_uid, uint8 stopped_periods ) public
  {
    UserSubscription sub = _get_subscription( sub_uid );
    require( sub.provider == msg.sender, RPSBase.EXN_AUTH_FAILED );
    sub.periods -= stopped_periods;
    _callbackSubscribe( sub, RPSBase.Status.Stopped);
  }
  
}

